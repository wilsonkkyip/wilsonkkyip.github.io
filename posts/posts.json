[
  {
    "path": "posts/2023-08-03-github-actions-with-example/",
    "title": "Github Actions with Example",
    "description": "An introduction to Github Actions with an example to write a post whenever a new blog post is merged to the main branch.",
    "author": [
      {
        "name": "Wilson Yip",
        "url": {}
      }
    ],
    "date": "2023-08-03",
    "categories": [
      "continuous-delivery",
      "cicd",
      "github-actions",
      "github"
    ],
    "contents": "\n\nContents\nIntroduction\nGithub Actions\nWorkflows\nEvents\nJobs\nActions\nRunners\nSecrets\nGithub Context\n\nLinkedIn API\nOAuth2\nCalling API\nIdentify User Id\nWrite Post\n\n\nAuto Posting Workflow\nThe Workflow\nThe Python Script\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\nIn modern software development, an engineer’s job does not end when a product is developed. Numerous times are spent on testing and deploying the product, no matter if the product is a website or a programming library or anything. Usually these tasks are repetitive and boring because these products are required to be maintained and updated. The same testing and deploying process will need to be rerun again throughout the life-cycle of the product.\nThe same problem happens on data scientists and machine learning engineers as well, where the models they have developed are also required to be tested and deployed (and updated and tested and deployed again and again). The concept of continuous integration and delivery came to automate these repetitive tasks and saves our precious time.\nThis article describes these concepts through an example – write a LinkedIn post whenever a new blog post is created in this blog. We will first briefly go through what Github Actions is, then we will talk about how to write a post on LinkedIn through its API. Finally we will create a workflow to check if there is a new blog post and write a LinkedIn post if there is.\nGithub Actions\nGithub Actions is a platform for continuous integration / continuous delivery (CI/CD). One can write workflows to automate build, testing, and deployment pipelines. Each workflow is triggered by one or more events and can be run by different runners. We will describe these concepts more below.\nEach workflow must be defined in the folder of .github/workflows in a repo and it must be specified in a YAML file like below. We will go through each section of the file.\n\n\n# Workflow Name\nname: Release Process\n\non:\n  # Events\n  push:                                   # One event\n    branches:\n      - main\n\n  workflow_run:                           # Another event\n    workflows: [pages-build-deployment]\n    types: \n      - completed\n\njobs:\n  # Job\n  generate-release:                 # Job id\n    name: Create GitHub Release     # Job name\n    runs-on: ubuntu-latest          # Runner\n    steps:\n    - name: Checkout Repository     # Step1\n      uses: actions/checkout@v2     # Actions\n      \n    - name: Run release code        # Step2\n      run: |\n        cd /target/directory\n        ./run-release-code\n  \n  # Another Job\n  another-job:                      # Job id\n    name: Another Job               # Job name\n    needs: [generate-release]       # Requires the job to complete successfully\n    runs-on: ubuntu-latest          # Runner\n    steps:\n    - name: Checkout Repository     # Step1\n      uses: actions/checkout@v2     # Actions\n      \n    - name: do other stuffs         # Step2\n      run: echo $CUSTOM_VAR\n      env: \n        CUSTOM_VAR: \"${{ secrets.CUSTOM_VAR }}\" # Secret value\n\n\nWorkflows\nThe entire YAML file specified in this code chunk is a workflow. There can be multiple workflows in different YAML files stored inside .github/workflows directory. Each workflow can be triggered by one or more events, or they can be triggered manually, or at a defined schedule. Each workflow can also contains one or more jobs.\nEvents\nAn event is an activity within the repository. For example, an event can be a pull / push request. It can also be the completion of another workflow or scheduled by cron syntax.\nThe above workflow will be triggered whenever one of the two specified events occurs. These two events are\nEvery time the main branch is pushed or merged from another branch, this workflow will be started.\nWhenever another workflow pages-build-deployment is completed, this workflow will be started.\nJobs\nA job is a series of steps that will be executed on the same runner. Each step is either a shell script or an action. The steps will be executed in order and dependent on each other. By default, each job will be run by a different runner and concurrently. One can specify the dependency of jobs by the key needs. The above example shows an implementation.\nAlso, one can also specify a strategy matrix to repeat the same job for different conditions. For example, the following job will be executed 6 times, namely\n{node-version: 10, os: ubuntu-22.04}\n{node-version: 10, os: ubuntu-20.04}\n{node-version: 12, os: ubuntu-22.04}\n{node-version: 12, os: ubuntu-20.04}\n{node-version: 14, os: ubuntu-22.04}\n{node-version: 14, os: ubuntu-20.04}\n\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, ubuntu-20.04]\n        version: [10, 12, 14]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.version }}\n\nActions\nActions are custom applications for GitHub Actions that perform complex but repetitive tasks. You can write an action from scratch or use an existing action available from the GitHub Marketplace in your workflow.\nRunners\nA runner is an OS on a virtual machine or container to execute a specific job. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run the workflows. One can also host their own machine as runner.\nSecrets\nFor each step or job, one can specify an env session to define environment variables. But if we are dealing with credentials, this might not be a good choice. One can go to Settings of the repository, under Security, click Secrets and variables, then click Actions. Inside the page, one can define secrets for the repository and can access them within the env session inside a workflow as shown in the example.\nGithub Context\nContexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For example the name of the working branch, the working directory of Github Actions, etc. The keyword secrets in the above section is also a context. See more from this page.\nLinkedIn API\nLinkedIn offers various API products for consumers to do various of things. One of which is to write posts on behalf of the users (see this documentation). To do that, we need to\nCreate a company on LinkedIn\nCreate an application on behalf of the company\nAuthenticate yourself and authorise the application to write posts on behalf of you\nThe process is similar to my previous blog post about OAuth2 for Google APIs. I will briefly describe the process here.\nOAuth2\nWe will first create a company on LinkedIn and the application.\nGo to https://developer.linkedin.com/ and click Create App (and login to your LinkedIn account)\nEnter the name of the application\nClick Create a new LinkedIn Page if you do not have a company on LinkedIn\nSelect Company\nEnter the name of the company, select the industry, company size, company type. Check the terms and click Create page\nGo back to the developer page and select the company just created\nUpload a logo for the application\nCheck the Legal agreement and click Create app\nClick Verify and follow the instruction\nClick Products, click Request access for both Share on LinkedIn and Sign in with LinkedIn\nClick Auth and copy the Client ID and Client Secret\nUnder OAuth 2.0 settings, enter the authorised redirect url\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we have the client_id, client_secret and redirect_uri ready, we can now authenticate ourselves and authorise the application. The following script will generate a url to login to your LinkedIn account. Then it will generate the access_token.\n\nimport os\nfrom urllib.parse import urlencode, urlparse\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport json\nimport requests\nimport webbrowser\n\nclient_id = os.getenv(\"CLIENT_ID\")\nclient_secret = os.getenv(\"CLIENT_SECRET\")\nredirect_uri = os.getenv(\"REDIRECT_URI\")\nscope = \"r_liteprofile w_member_social openid profile email\"\n\ndef parse_query(path):\n    parsed_url = urlparse(path)\n    query = parsed_url.query.split(\"&\")\n    query = [x.split(\"=\") for x in query]\n    query = {x[0]: x[1] for x in query}\n    return query\n\ndef auth_code(code, client_id, client_secret, redirect_uri):\n    params = {\n        \"grant_type\": \"authorization_code\",\n        \"code\": code,\n        \"redirect_uri\": redirect_uri,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret\n    }\n    headers = {\n        \"content-type\": \"application/x-www-form-urlencoded\",\n        \"content-length\": \"0\"\n    }\n    url = \"https://www.linkedin.com/oauth/v2/accessToken\"\n    response = requests.post(url, params=params, headers=headers)\n    response.raise_for_status()\n    content = response.json()\n    return content\n\nclass NeuralHTTP(BaseHTTPRequestHandler):\n    def do_GET(self):\n        path = self.path\n        query = parse_query(path)\n\n        code = query.get(\"code\")\n        if code:\n            status_code = 200\n            content = auth_code(\n                code=query.get(\"code\"),\n                client_id=client_id,\n                client_secret=client_secret,\n                redirect_uri=redirect_uri\n            )\n            print(json.dumps(content, indent=4))\n        else:\n            status_code = 400\n            content = {\n                \"error\": \"code not found\"\n            }\n\n        self.send_response(status_code)\n        self.send_header(\"Content-Type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(bytes(json.dumps(content, indent=4), \"utf-8\"))\n    \n    def log_message(self, format, *args):\n        \"\"\"Silence log message. Can be ignored.\"\"\"\n        return\n\nif __name__ == \"__main__\":\n    with HTTPServer((\"127.0.0.1\", 8088), NeuralHTTP) as server:\n        auth_url = \"https://www.linkedin.com/oauth/v2/authorization\"\n        params = {\n            \"client_id\": client_id,\n            \"response_type\": \"code\",\n            \"redirect_uri\": redirect_uri,\n            \"scope\": scope,\n        }\n\n        url = f\"{auth_url}?{urlencode(params)}\"\n        webbrowser.open(url)\n        server.handle_request()\n\n\n# {\n#     \"access_token\": \"...\",\n#     \"expires_in\": 5183999,\n#     \"scope\": \"email,openid,profile,r_liteprofile,w_member_social\",\n#     \"token_type\": \"Bearer\",\n#     \"id_token\": \"...\"\n# }\n\nCalling API\nIdentify User Id\nTo write a post on LinkedIn, We need to first identify the author’s user_id. A GET request to https://api.linkedin.com/v2/userinfo with the access_token obtained from the above are needed.\n\nimport os\nimport requests \nimport json\n\nurl = \"https://api.linkedin.com/v2/userinfo\"\ntoken = os.getenv(\"LINKEDIN_ACCESS_TOKEN\")\n\nheaders = {\"Authorization\": f\"Bearer {token}\"}\n\nresponse = requests.get(url, headers=headers)\nresponse.raise_for_status()\ncontent = response.json()\nprint(json.dumps(content, indent=4))\n\n\n{\n    \"sub\": \"....\",\n    \"email_verified\": true,\n    \"name\": \"Wilson Yip\",\n    \"locale\": {\n        \"country\": \"US\",\n        \"language\": \"en\"\n    },\n    \"given_name\": \"Wilson\",\n    \"family_name\": \"Yip\",\n    \"email\": \"wilsonyip@elitemail.org\",\n    \"picture\": \"https://media.licdn.com/dms/image/C4E03AQGo1BKbUYmyBA/profile-displayphoto-shrink_100_100/0/1646639382257?e=1696464000&v=beta&t=6lhHrDK3vx6GOC01wIKkfVYAmCiSWoZtc8XpE0JoUmM\"\n}\n\nThe user_id is stored in the sub value.\nWrite Post\nWe will be calling the Share in LinkedIn endpoint to write a post in LinkedIn along with the specific request body to attach an article to the post. The following scripts shows an example.\n\nimport os\nimport requests \n\ndef build_post_body(\n    user_id, \n    post_content, \n    media_title, \n    media_description, \n    article_url\n):\n    body = {\n        \"author\": f\"urn:li:person:{user_id}\",\n        \"lifecycleState\": \"PUBLISHED\",\n        \"specificContent\": {\n            \"com.linkedin.ugc.ShareContent\": {\n            \"shareCommentary\": {\n                    \"text\": post_content\n                },\n                \"shareMediaCategory\": \"ARTICLE\",\n                \"media\": [\n                    {\n                        \"status\": \"READY\",\n                        \"description\": {\n                            \"text\": media_description\n                        },\n                        \"originalUrl\": article_url,\n                        \"title\": {\n                            \"text\": media_title\n                        }\n                    }\n                ]\n            }\n        },\n        \"visibility\": {\n            \"com.linkedin.ugc.MemberNetworkVisibility\": \"PUBLIC\"\n        }\n    }\n    return body\n\nif __name__ == \"__main__\":\n    linkedin_user_id = os.getenv(\"LINKEDIN_USER_ID\")    # user_id \n    linkedin_token = os.getenv(\"LINKEDIN_TOKEN\")        # access_token\n    linkedin_post_endpoint = \"https://api.linkedin.com/v2/ugcPosts\"\n\n    headers = {\n        \"X-Restli-Protocol-Version\": \"2.0.0\",\n        \"Authorization\": \"Bearer \" + linkedin_token \n    }\n\n    body = build_post_body(\n        user_id=linkedin_user_id,\n        post_content=\"Content of the LinkedIn post\",\n        media_title=\"The title of the article\",\n        media_description=\"The description of the article\",\n        article_url=\"https://www.link-to-article.com/article\"\n    )\n\n    response = requests.post(\n        url=linkedin_post_endpoint, \n        json=body, \n        headers=headers\n    )\n\nAuto Posting Workflow\nA workflow is created to write a post on LinkedIn whenever there is a new article merged to the main branch of a repository. The workflow is triggered every time after completion of the pages-build-deployment workflow, which is the workflow to build the website. Yet, there is a problem:\n\nWe need to keep tract which article was posted to LinkedIn already in order to define which article is new.\n\nFor simplicity, I have created a Google Sheet to store the article paths and the corresponding LinkedIn post_id. If an article’s path does not appear in the table, that is the new article and will further trigger the scripts.\nThe workflow is quite simple. It just runs a Python file. The Python file will check if there are any new article path, write a LinkedIn post if there is one, and update the log file.\nThe Workflow\n\nname: create-linkedin-post\n\non:\n  workflow_run:\n    workflows: [pages-build-deployment]\n    types: \n      - completed\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Chekcout\n        uses: actions/checkout@v3\n      \n      - name: Install python dependencies\n        run: pip install pyyaml\n      \n      - name: Create Linkedin Post\n        run: python ./tools/cd/linkedin_post.py\n        env: \n          LINKEDIN_USER_ID: ${{ secrets.LINKEDIN_USER_ID }}\n          LINKEDIN_TOKEN: ${{ secrets.LINKEDIN_TOKEN }}\n          GCP_CLIENT_EMAIL: ${{ secrets.GCP_CLIENT_EMAIL }}\n          GCP_PRIVATE_KEY_ID: ${{ secrets.GCP_PRIVATE_KEY_ID }}\n          GCP_PRIVATE_KEY: ${{ secrets.GCP_PRIVATE_KEY }}\n          LINKEDIN_POSTS_LOG_SSID: ${{ secrets.LINKEDIN_POSTS_LOG_SSID }}\n          LINKEDIN_POSTS_LOG_RANGE: ${{ secrets.LINKEDIN_POSTS_LOG_RANGE }}\n\nThe Python Script\n\n#!/usr/bin/python\n\nimport os\nimport requests \nimport json \nfrom time import time\nimport jwt\nimport yaml\n\ndef build_post_body(\n    user_id, \n    post_content, \n    media_title, \n    media_description, \n    article_url\n):\n    body = {\n        \"author\": f\"urn:li:person:{user_id}\",\n        \"lifecycleState\": \"PUBLISHED\",\n        \"specificContent\": {\n            \"com.linkedin.ugc.ShareContent\": {\n            \"shareCommentary\": {\n                    \"text\": post_content\n                },\n                \"shareMediaCategory\": \"ARTICLE\",\n                \"media\": [\n                    {\n                        \"status\": \"READY\",\n                        \"description\": {\n                            \"text\": media_description\n                        },\n                        \"originalUrl\": article_url,\n                        \"title\": {\n                            \"text\": media_title\n                        }\n                    }\n                ]\n            }\n        },\n        \"visibility\": {\n            \"com.linkedin.ugc.MemberNetworkVisibility\": \"PUBLIC\"\n        }\n    }\n    return body\n\ndef find_latest_missing_post(page_posts, linkedin_posts):\n    page_post_paths = [x.get(\"path\") for x in page_posts]\n    linkedin_post_paths = [x.get(\"path\") for x in linkedin_posts]\n    missing_idx = [\n        i for i, x in enumerate(page_post_paths) if x not in linkedin_post_paths\n    ]\n    \n    if missing_idx:\n        missing_paths = [page_post_paths[i] for i in missing_idx]\n        missing_post_dates = [page_posts[i].get(\"date\") for i in missing_idx]\n        latest_missing_post = missing_paths[missing_post_dates.index(max(missing_post_dates))]\n        latest_missing_post = page_posts[page_post_paths.index(latest_missing_post)]\n    else:\n        latest_missing_post = None\n\n    return latest_missing_post\n\ndef read_rmd_yml(path):\n    with open(path, \"r\") as f:\n        rmd_yml = f.readlines()\n    \n    yml_idx = [i for i, x in enumerate(rmd_yml) if x == \"---\\n\"]\n    return yaml.safe_load(\"\".join(rmd_yml[(yml_idx[0]+1):(yml_idx[1])]))\n\ndef auth_gapi_token(client_email, private_key_id, private_key):\n    payload: dict = {\n        \"iss\": client_email,\n        \"scope\": \"https://www.googleapis.com/auth/drive\",\n        \"aud\": \"https://oauth2.googleapis.com/token\",\n        \"iat\": int(time()),\n        \"exp\": int(time() + 3599)\n    }\n    headers: dict[str, str] = {'kid': private_key_id}\n\n    signed_jwt: bytes = jwt.encode(\n        payload=payload,\n        key=private_key.replace(\"\\\\n\", \"\\n\"),\n        algorithm=\"RS256\",\n        headers=headers\n    )\n\n    body: dict = {\n        \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n        \"assertion\": signed_jwt\n    }\n    response: requests.Response = requests.request(\n        \"POST\", \"https://oauth2.googleapis.com/token\", json=body\n    )\n\n    response.raise_for_status()\n\n    content = response.json()\n    return content.get('access_token')\n\ndef read_gsheet(ssid, ranges, token):\n    url = f\"https://sheets.googleapis.com/v4/spreadsheets/{ssid}/values/{ranges}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef append_gsheet(ssid, ranges, data, token):\n    url = f\"https://sheets.googleapis.com/v4/spreadsheets/{ssid}/values/{ranges}:append\"\n\n    body = {\n        \"range\": ranges,\n        \"majorDimension\": \"ROWS\",\n        \"values\": data\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    response = requests.post(url, params={\"valueInputOption\": \"RAW\"}, headers=headers, json=body)\n    response.raise_for_status()\n\ndef create_linkedin_post(post):\n    linkedin_user_id = os.getenv(\"LINKEDIN_USER_ID\")\n    linkedin_token = os.getenv(\"LINKEDIN_TOKEN\")\n    linkedin_post_endpoint = \"https://api.linkedin.com/v2/ugcPosts\"\n\n    rmd_file = os.listdir(f\"./_{post['path']}\")\n    rmd_file = list(filter(lambda x: \".rmd\" in x.lower(), rmd_file))[0]\n\n    rmd_yml = read_rmd_yml(f\"./_{post['path']}/{rmd_file}\")\n    post_note = \"The post was created by Github Actions.\\nhttps://github.com/wilsonkkyip/wilsonkkyip.github.io\"\n    abstract = rmd_yml[\"abstract\"] + f\"\\n\\n{post_note}\"\n\n    body = build_post_body(\n        user_id=linkedin_user_id,\n        post_content=abstract,\n        media_title=rmd_yml[\"title\"],\n        media_description=rmd_yml[\"description\"],\n        article_url=f\"https://wilsonkkyip.github.io/{post['path']}\"\n    )\n\n    headers = {\n        \"X-Restli-Protocol-Version\": \"2.0.0\",\n        \"Authorization\": \"Bearer \" + linkedin_token \n    }\n\n    response = requests.post(\n        url=linkedin_post_endpoint, \n        json=body, \n        headers=headers\n    )\n\n    content = response.json()\n\n    return content\n\n\ndef main():\n    gcp_client_email = os.getenv(\"GCP_CLIENT_EMAIL\")\n    gcp_private_key_id = os.getenv(\"GCP_PRIVATE_KEY_ID\")\n    gcp_private_key = os.getenv(\"GCP_PRIVATE_KEY\")\n\n    log_ssid = os.getenv(\"LINKEDIN_POSTS_LOG_SSID\")\n    log_range = os.getenv(\"LINKEDIN_POSTS_LOG_RANGE\")\n\n    gcp_token = auth_gapi_token(\n        gcp_client_email, gcp_private_key_id, gcp_private_key\n    )\n\n    logs = read_gsheet(log_ssid, log_range, gcp_token)\n    linkedin_posts = [\n        {logs[\"values\"][0][0]: x[0], logs[\"values\"][0][1]: x[1]} for x in logs[\"values\"][1:]\n    ]\n\n    with open(\"./posts/posts.json\", \"r\") as file:\n        page_posts = json.loads(file.read())\n\n    missing_post = find_latest_missing_post(page_posts, linkedin_posts)\n\n    if missing_post:\n        response = create_linkedin_post(missing_post)\n        appending_data = [[missing_post[\"path\"], response.get(\"id\")]]\n        append_gsheet(log_ssid, log_range, appending_data, gcp_token)\n\nif __name__ == \"__main__\": \n    main()\n\n\n\n\n",
    "preview": "posts/2023-08-03-github-actions-with-example/img/github-actions.png",
    "last_modified": "2023-08-03T17:50:00+00:00",
    "input_file": "github-actions-with-example.knit.md"
  },
  {
    "path": "posts/2023-07-29-rust-gapi-oauth2/",
    "title": "Google OAuth2 Implementation on Rust Reqwest",
    "description": "An implementation of Google OAuth2 procedures on Rust reqwest for Server-side Web Apps and Service Accounts.",
    "author": [
      {
        "name": "Wilson Yip",
        "url": {}
      }
    ],
    "date": "2023-07-29",
    "categories": [
      "rust",
      "oauth2",
      "google-oauth"
    ],
    "contents": "\n\nContents\nIntroduction\nOAuth2 Procedures\nCreate Google Cloud Project\nSelect Required Library\nCreate OAuth Client ID Secrets\nConfigure OAuth Consent Screen\nCreate OAuth Client ID for Users\n\nService Account\n\nRust Reqwest Implementation\nAuthorise Client Application (Client ID)\nAuthorise Client Application (Refresh Token)\nAuthorise Service Account\n\nExamples\n\n\n\n\nIntroduction\nIt comes to me on many occasions that Google APIs are required to complete my tasks. API keys may be an easy choice for those non-sensitive scopes (for example calling YouTube API for some public videos and channels). But when it comes to handling files in Google Drive, things become complicated as the service requires authentication and authorisation. This article aims to provide a solution on obtaining an authorised token to be put in http requests’ header for calling the Google APIs’ sensitive scopes in Rust environment.\nA Github repo was created for the purpose. It can be used in CLI environment and imported as rust crate as well. Below will first briefly describe the OAuth2 procedures, then walk through some important script, and finally will show some examples using of the crate.\nOAuth2 Procedures\nWhen I first encountered OAuth2, I was confused about what scopes and endpoints are because both scopes and endpoints are represented by url-like strings in Google APIs. In a nutshell, endpoints represent what services you want to use. For example there is a specific endpoint for reading the metadata of a file in Google Drive; there is another endpoint for you to update the file. On the other hand, scopes are the abilities of your authorised token. For example, is your token able to read the files from Google Drive? It depends on whether your token contains the specific scope.\nGoogle separates the authorisation method for server-to-server interactions and user-to-server interactions. We will use a service account for the prior situation and a client secret for the later one. Both can be represented by a JSON file. To obtain these JSON files, we first need to create a Google Cloud Project. Then within the project, we can create the secret JSON files.\n\n\n\n\n\n\nCreate Google Cloud Project\nGo to https://console.developers.google.com and click Select a project.\nClick New Project.\nEnter the Project name and click Create.\n\n\n\n\n\n\n\n\n\n\n\n\nSelect Required Library\nUnder APIs and service, click Library.\nSearch the API library(ies) you wish to use. In this example, we choose Google Drive API.\nClick the library you want.\nClick Enable.\n\n\n\n\n\n\n\n\n\n\n\n\nCreate OAuth Client ID Secrets\nNow we have created a project and picked the required libraries. This section will show how to obtain a client_secret of the application for users to authorise. In order to do so, we need to first configure an OAuth consent screen to inform users about the name of the application and which scopes will be used by the application when they do the authorisation. Then we will create the application secret (or client_secret) for this application.\nConfigure OAuth Consent Screen\nUnder APIs and services, Credentials, click Configure consent screen or OAuth consent screen.\nIf you are within an organisation, you can pick Internal or External as User Type. Otherwise, you can only pick External.\nFor internal apps, it is only available to users within the organisation. But the app is not required to have any privacy policy.\nFor external apps, you can add at most 100 test users for testing the application before published. But the refresh_token obtained from the authorisation and authentication process is only valid for 1 week only.\n\nEnter the App name and User support email.\nScroll down and enter the developer contact information and click Save and continue.\nClick Add or remove scopes.\nSelect the scopes you want to use.\nClick Save and continue.\n(For external apps only) Click Add users as test users for the application.\n(For external apps only) Enter the email address(es) for the test user(s). Then click Add.\nClick Save and continue.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate OAuth Client ID for Users\nUnder APIs and services, Credentials, click Create Credentials, then click OAuth client ID.\nSelect Web application as Application type and enter the name of the application.\nScroll down and enter the Authorised redirect URIs. Please put a slash (/) at the end of the uri. Then click Create.\nFinally click Download JSON.\n\n\n\n\n\n\n\n\n\n\n\n\nService Account\nThis section describe how to obtain a service account JSON. If you wish to handle users’ data, please follow this section.\nUnder APIs and services, Credentials, click Create Credentials, then click Service Account.\nInsert the name, account id, and description of the service account. Then click Done.\nClick the newly created service account email.\nClick Keys, then clickAdd key and Create new key.\nSelect JSON as key type and click Create to download the service account JSON.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRust Reqwest Implementation\nNow we have obtained the secret JSON (either a client_seceret or a service_account or both). Depends on which type of secret we have, the authorisation methods are different.\nAuthorise Client Application (Client ID)\nFor authorising a client application (see this figure), we need to\nBuild a url with the follow query parameters:\nclient_id (the identification of the client application)\nredirect_uri (those we specified in step 3 in this section, put 1 uri here only)\nscope (the scopes the application wants to use; space-delimited if more than one is used)\naccess_type (either online of offline. A refresh_token will be obtained in later step for acquiring updated access token without another consent from the users)\n\nYou can specified more parameters for different configuration. See more from here.\nSend a request to Google OAuth page using the above url. Google will also ask for user consent in this stage.\nGoogle returns an authorisation code to the redirect_uri we specified above.\nSend another request to Google with the authorisation code obtained from the last step to exchange an access_token (and refresh_token if specified in step 1).\nThis access_token can use used to access the authorised endpoints.\n\n\n\nFigure 1: Authorise client application\n\n\n\nAmong the JSON obtained from this section, we create the following struct for the key-value pairs.\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ClientSecret {\n    pub client_id: String,\n    pub project_id: String,\n    pub auth_uri: String,\n    pub token_uri: String,\n    pub auth_provider_x509_cert_url: String,\n    pub client_secret: String,\n    pub redirect_uris: Vec<String>\n}\n\nThen we implement a method to the above struct to build the url for step 1.\n\npub fn auth_url(&self, scope: &str) -> String {\n    let params: HashMap<_,_> = HashMap::from([\n        (\"response_type\", \"code\"),\n        (\"access_type\", \"offline\"), // set 'offline' to obtain 'refresh_token'\n        (\"prompt\", \"consent\"),\n        (\"client_id\", &self.client_id),\n        (\"redirect_uri\", &self.redirect_uris[0]),\n        (\"scope\", &scope),\n        (\"state\", &self.client_id)\n    ]);\n\n    let url = reqwest::Url::parse_with_params(\n        &self.auth_uri, params\n    ).expect(\"Failed to parse auth url.\").to_string();\n    \n    return url;\n}\n\nNow we need to print out the above url and set up a http server to listen from Google’s response with the authorisation code to finish step 3.\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct AuthCode {\n    pub code: String,\n    pub scope: String\n}\n\npub fn auth_code(&self, scope: &str, port: u32) -> Result<AuthCode, std::io::Error> {\n    let auth_url: String = self.auth_url(scope);\n    println!(\"Please visit this URL to authorize this application: {}\", auth_url);\n\n    let listener: TcpListener = \n        TcpListener::bind(format!(\"localhost:{}\", port))\n            .expect(\"Failed to bind to port\");\n    \n    let (mut stream, _) = listener.accept().unwrap();\n    let mut buf = [0;2048];\n    stream.read(&mut buf).unwrap();\n\n    let buf_str: String = String::from_utf8_lossy(&buf[..]).to_string();\n    let buf_vec: Vec<&str> = buf_str\n        .split(\" \")\n        .collect::<Vec<&str>>();\n\n    let args: String = buf_vec[1].to_string();\n    let callback_url: Url = Url::parse(\n        (format!(\"http://localhost:{}\", port) + &args).as_str()\n    ).expect(\"Failed to parse callback URL\");\n    let query: HashMap<_,_> = callback_url.query_pairs().into_owned().collect();\n    let output = AuthCode {\n        code: query.get(\"code\").unwrap().to_string(),\n        scope: query.get(\"scope\").unwrap().to_string()\n    };\n    return Ok(output);\n}\n\nFor step 4, the following function will prepare a POST request to Google to exchange the authorisation code for the access_token (and refresh_token).\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ClientSecretTokenResponse {\n    pub access_token: String,\n    pub expires_in: i64,\n    pub refresh_token: String,\n    pub scope: String,\n    pub token_type: String\n}\n\npub async fn auth_token(&self, code: &str) -> Result<ClientSecretTokenResponse, reqwest::Error> {\n    let body: Value = serde_json::json!({\n        \"client_id\": self.client_id,\n        \"client_secret\": self.client_secret,\n        \"code\": code,\n        \"grant_type\": \"authorization_code\",\n        \"redirect_uri\": self.redirect_uris[0]\n    });\n\n    let response = reqwest::Client::new()\n        .post(self.token_uri.as_str())\n        .json(&body)\n        .send()\n        .await?;\n\n    let content: ClientSecretTokenResponse = response.json()\n        .await.expect(\"Failed to parse http response\");\n\n    return Ok(content);\n}\n\nAuthorise Client Application (Refresh Token)\nWhen we obtained the refresh_token from the above, we can further request a new access_token when the previous one is expired. To do do, we first define a struct and implement an auth function to it.\n\npub const OAUTH_TOKEN_URL: &str = \"https://oauth2.googleapis.com/token\";\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Token {\n    pub access_token: String,\n    pub expires_in: i64\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct UserSecret {\n    pub client_id: String,\n    pub client_secret: String,\n    pub refresh_token: String\n}\n\npub async fn auth(&self) -> Result<Token, reqwest::Error> {\n    // Prepare auth body\n    let mut body: Value = serde_json::to_value(&self)\n        .expect(\"Could not convert UserSecret to Value\");\n    body[\"grant_type\"] = Value::String(\"refresh_token\".to_string());\n\n    // Auth request\n    let response: reqwest::Response = reqwest::Client::new()\n        .post(OAUTH_TOKEN_URL)\n        .json(&body)\n        .send()\n        .await?;\n\n    // Parse response to output\n    let content: Token = response.json().await?;\n\n    return Ok(content)\n}\n\nAuthorise Service Account\nFor authorising a service account (see this figure), we need to\nPrepare a JWT token. The token is separated into 3 parts:\nHeader: consist of the algorithm name and the privated_key_id (from the secret JSON).\nClaim: consist of client_email, scope, aud, iat and exp.\nKey: the private_key from the secret JSON.\n\nUse the JWT token to exchange the access_token.\n\n\n\nFigure 2: Authorise service account\n\n\n\nBelow shows the implementation.\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ServiceSecret {\n    pub client_email: String,\n    pub private_key_id: String,\n    pub private_key: String\n}\n\npub async fn auth(&self, scope: &str) -> Result<Token, reqwest::Error> {\n    // Auth Service Account\n    // https://developers.google.com/identity/protocols/oauth2/service-account\n\n    // Prepare JWT claim\n    let claim: serde_json::Value = serde_json::json!({\n        \"iss\": self.client_email.to_string(),\n        \"scope\": scope.to_string(),\n        \"aud\": \"https://oauth2.googleapis.com/token\".to_string(),\n        \"iat\": chrono::offset::Utc::now().timestamp(),\n        \"exp\": chrono::offset::Utc::now().timestamp() + 3600\n    });\n\n    // Prepare JWT header\n    let header: Header = Header{\n        alg: Algorithm::RS256,\n        kid: Some(self.private_key_id.to_string()),\n        ..Default::default()\n    };\n\n    // Prepare JWT key\n    let key: EncodingKey = EncodingKey::from_rsa_pem(\n        &self.private_key\n            .to_string()\n            .replace(\"\\\\n\", \"\\n\").as_bytes()\n    ).expect(\"Cannot build `EncodingKey`.\");\n\n    // Generate JWT\n    let token: String = encode(\n        &header, &claim, &key\n    ).expect(\"Cannot encode `token`.\");\n\n    // Auth JWT\n    let response: Response = reqwest::Client::new()\n        .post(OAUTH_TOKEN_URL)\n        .json(&serde_json::json!({\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n            \"assertion\": token\n        }))\n        .send()\n        .await?;\n    \n    // Prepare output\n    let content: Token = match response.status() {\n        StatusCode::OK => response.json().await.expect(\"Unable to parse HTTP response JSON.\"),\n        StatusCode::UNAUTHORIZED => {\n            println!(\"{}\", response.text().await.unwrap());\n            panic!(\"HTTP request failed: Unauthorized.\");\n        },\n        _ => {\n            println!(\"{}\", response.text().await.unwrap());\n            panic!(\"HTTP request failed.\");\n        }\n    };\n\n    return Ok(content);\n}\n\nExamples\nA main.rs was also written in the Github repo to provide accessibility from command prompt.\n\ncargo run \n\n# Usage: gapi-oauth <SERVICE> <JSON_PATH> [SCOPE] [PORT]\n# \n# SERVICE: `user`, `service`, or `consent`\n# JSON_PATH: The path to the JSON file containing the credentials.\n# SCOPE: Only required for `service` and `consent`\n# PORT: Only required for `consent`\n\n\ncargo run user /path/to/client_token.json\n\n# {\n#   \"access_token\": \"...\",\n#   \"expires_in\": 3599\n# }\n\n\ncargo run user /path/to/service_acc.json 'https://www.googleapis.com/auth/drive'\n\n# {\n#   \"access_token\": \"...\",\n#   \"expires_in\": 3599\n# }\n\n\ncargo run consent /path/to/client_secret.json 'https://www.googleapis.com/auth/drive' 8088\n\n# Please visit this URL to authorize this application: \n# https://accounts.google.com/o/oauth2/auth?client_id=&prompt=consent&...\n# \n# {\n#   \"access_token\": \"...\",\n#   \"refresh_token\": \"...\",\n#   \"scopes\": [\n#     \"https://www.googleapis.com/auth/drive\"\n#   ],\n#   \"expiry\": \"2023-07-30T17:51:13.123456Z\",\n#   \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n#   \"token_uri\": \"https://oauth2.googleapis.com/token\",\n#   \"client_id\": \"...\",\n#   \"client_secret\": \"...\"\n# }\n\nIt can also be used as crate. After constructing the UserSecret or ServiceSecret, simply use the corresponding auth method to return the access_token.\n\nuse crate::auth_users::UserSecret;\nuse crate::auth_service::ServiceSecret;\n\n#[tokio::test]\nasync fn test_auth_user() {\n    let client_id = std::env::var(\"USER_CLIENT_ID\")\n        .expect(\"No USER_CLIENT_ID in env var\")\n        .as_str().to_string();\n    let client_secret = std::env::var(\"USER_CLIENT_SECRET\")\n        .expect(\"No USER_CLIENT_SECRET in env var\")\n        .as_str().to_string();\n    let refresh_token = std::env::var(\"USER_REFRESH_TOKEN\")\n        .expect(\"No USER_REFRESH_TOKEN in env var\")\n\n    // Construct UserSecret\n    let client_token = UserSecret {\n        client_id: client_id,\n        client_secret: client_secret,\n        refresh_token: refresh_token,\n    };\n\n    // Auth to Token, will panic if failed.\n    let _token = client_token.auth().await\n        .expect(\"Unable to authenticate\");\n}\n\n#[tokio::test]\nasync fn test_auth_service() {\n    let client_email = std::env::var(\"SERVICE_CLIENT_EMAIL\")\n        .expect(\"No SERVICE_CLIENT_EMAIL in env var\")\n        .as_str().to_string();\n    let private_key = std::env::var(\"SERVICE_PRIVATE_KEY\")\n        .expect(\"No SERVICE_PRIVATE_KEY in env var\")\n        .as_str().to_string();\n    let private_key_id = std::env::var(\"SERVICE_PRIVATE_KEY_ID\")\n        .expect(\"No SERVICE_PRIVATE_KEY_ID in env var\")\n        .as_str().to_string();\n\n    let service_secret = ServiceSecret {\n        client_email: client_email,\n        private_key: private_key,\n        private_key_id: private_key_id,\n    };\n\n    let scopes: Vec<String> = vec![\n        \"https://www.googleapis.com/auth/drive\".to_string(),\n        \"https://www.googleapis.com/auth/youtube\".to_string()\n    ];\n\n    let scope = scopes.join(\" \");\n\n    let _token = service_secret.auth(&scope).await\n        .expect(\"Unable to authenticate\");\n}\n\n\n\n\n",
    "preview": "https://raw.githubusercontent.com/wilsonkkyip/wilsonkkyip.github.io/main/img/wy_logo.png",
    "last_modified": "2023-08-03T17:42:30+00:00",
    "input_file": "rust-gapi-oauth2.knit.md"
  }
]
